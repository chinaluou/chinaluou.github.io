<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[CODESYS功能块建库移植到底层平台]]></title>
      <url>%2F2018%2F04%2F10%2FCODSYS%E5%8A%9F%E8%83%BD%E5%9D%97%E5%BB%BA%E5%BA%93%E7%A7%BB%E6%A4%8D%E5%88%B0%E5%BA%95%E5%B1%82%E5%B9%B3%E5%8F%B0%2F</url>
      <content type="text"><![CDATA[1. CODESYS平台Lib库的建立 本文以CODESYS V3.5 SP6平台建立一个温度控制PID算法建库，在CODESYS中建立函数接口，具体算法在底层实现。 打开CODESYS软件，点击”新建工程”，选择”函数库”中的”空白库”，设定文件目录和文件名，如文件夹为：”Temperature”文件名为：”CmpTemperature”，然后确认。 在POU中选中”CmpTemperature”，右键”添加对象”，单击”程序组织单元…”。 在创建新的POU窗口中，输入名称”MC_TemperatureRegulator”,类型为”功能块”，实现语言为”功能块图(FBD)”，然后点击打开。 在POU中选中”MC_TemperatureRegulator”，右键”添加对象”，单击”方法…”。 在创建新的方法窗口中，输入名称”FB_Init”，实现语言为”功能块图(FBD)”，然后点击打开。 在POU中右键”MC_TemperatureRegulator”，单击”属性…”，单击”编译”选项卡，勾选”外部实现(E)(稍后在系统运行时连接)”，点击确认。同样对”FB_Init”，也进行同样的操作。（因为我们只是在CODESYS中定义接口函数，具体执行放到底层硬件中去实现） 在POU中双击”MC_TemperatureRegulator”，然后在右侧变量窗口中填写功能块的接口数参数，其中Axis、TemperatureExpect、TemperatureActual、DutyRatio为自定义参数，其他参数为默认参数。 12345678910111213141516171819202122FUNCTION_BLOCK MC_TemperatureRegulator(* Function block for temperature control *)(* Function block for PWM duty ratio from expect temperature and actual temperature to Fuzzy *)VAR_IN_OUT Axis: hAxis_REF; (* Reference to the Axis *)END_VARVAR_INPUT Execute: BOOL := 0; (* Start the motion at rising edge *) TemperatureExpect: REAL := 0.0; (* Expect temperature. In technical unit [degree C] *) TemperatureActual: REAL := 0.0; (* Actual temperature. In technical unit [degree C] *) END_VARVAR_OUTPUT DutyRatio: REAL := 0; (* PWM duty ratio (0.0 ~ 100.0) *) Done: BOOL := 0; (* Commanded is done *) Busy: BOOL := 0; (* The FB is not finished *) Error: BOOL := 0; (* Signals that an error has occurred within the function block *) ErrorID: WORD := 1; (* Error identification *)END_VARVAREND_VAR 在POU中双击”FB_Init”，然后在右侧变量窗口中填写功能块的接口数参数，其中参数为默认参数。 12345METHOD FB_Init : BOOLVAR_INPUT bInitRetains: BOOL; bInCopyCode: BOOL;END_VAR 由于在”MC_TemperatureRegulator”的参数申明中，使用私有数据类型”hAxis_REF”，因此编译会报错提示”C0077: 未知的类型: ‘hAxis_REF’”，这个数据类型申明在数据类型库中进行了定义，因此需要添加这个库。在POU中右击”CmpTemperature”，选择”添加对象”，单击”库管理器…”，点击”打开”。然后在右侧单击”添加库”，在”杂项”中，选中”PLCOpen Motion Basic”，点击确认，就完成了库的添加，也可以看库中定义的数据类型。（当然在POU中添加”PLCOpen Motion Basic”这个库，前提是已经在”工具”栏中，”安装库…”中完成了这个库导入CODESYS） 选择菜单栏中的”编译”，单击”检测所有池对象”，对程序进行错误检测，如果没有错误后，选择选择菜单栏中的”编译”，单击”生产运行时系统文件”，勾选”C根文件”后点击”确认”。 此时，会在文件目录下生成”CmpTemperature.library”、”CmpTemperature.c”、”CmpTemperatureItf.m4”等文件，至此就完成了CODESYS平台下的Lib库的建立。 2. 生成底层平台所需要的文件 在其他目录下新建一个文件夹”Temperature”，拷贝CODESYS生成”CmpTemperature.library”、”CmpTemperature.c”、”CmpTemperatureItf.m4”文件，到新建的文件夹。 在新建文件夹中新建文件”CmpTemperatureItf.m4”，具体内容如下所示： 1234567891011121314151617181920212223242526/** * &lt;name&gt;Component Template&lt;/name&gt; * &lt;description&gt; * An example on how to implement a component. * This component does no usefull work and it exports no functions * which are intended to be used for anything. Use at your own risk. * &lt;/description&gt; * &lt;copyright&gt; * (c) 2003-2016 3S-Smart Software Solutions * &lt;/copyright&gt; */SET_COMPONENT_NAME(`CmpTemperature')COMPONENT_SOURCES(`CmpTemperature.c')COMPONENT_VERSION(`0x03050600')/* NOTE: REPLACE 0x0001 BY YOUR VENDORID */COMPONENT_VENDORID(`0x0001') #define CMPID_CmpTemperature 0x2000 /* NOTE: START HERE WITH YOUR COMPONENTIDS (see CmpItf.h */#define CLASSID_CCmpTemperature ADDVENDORID(CMP_VENDORID, 0x2000) /* NOTE: START HERE WITH YOUR CLASSIDS (see CmpItf.h */#define ITFID_ICmpTemperature ADDVENDORID(CMP_VENDORID, 0x2000) /* NOTE: START HERE WITH YOUR INTERFACEIDS (see CmpItf.h */CATEGORY(`Hilectro')IMPLEMENT_ITF(`CmpTemperatureItf.m4') 在新建文件夹中新建批处理文件”CmpTemperatureDep_m4.bat”，具体内容如下所示： 123echo. * CmpTemperatureDep.m4 ... CmpTemperatureDep.h start /B /WAIT ..\..\BuildUtils\msys\bin\generate_dep_withCpp.bat CmpTemperatureDep ..\..\BuildUtils\msys\bin ../../BuildUtils/M4Defs ../../Components 在新建文件夹中新建批处理文件”CmpTemperatureItf_m4.bat”，具体内容如下所示： 1234echo. * CmpTemperatureItf.m4 ... CmpTemperatureItf.h start /B /WAIT ..\..\BuildUtils\msys\bin\generate_itf.bat CmpTemperatureItf ..\..\BuildUtils\msys\bin ../../BuildUtils/M4Defs 依次双击批处理文件”CmpTemperatureDep_m4.bat”、”CmpTemperatureItf_m4.bat”，会在目录下生成文件”CmpTemperature.cpp”、”CmpTemperatureDep.h”、”CmpTemperatureItf.h”三个文件。 至此底层平台所需的文件已经产生。 3. 移植代码至底层平台 本移植例程以笔者目前的A8工程平台下进行举例说明，笔者底层工程平台将底层和CODESYS连接所需的依赖关系和函数实现分开放置。底层和CODESYS连接所需的依赖关系文件放置在”CODESYS”目录下，函数实现放在”CMP”目录下。 在”CODESYS”的”H7”目录下新建文件夹”CmpTemperature”，在新建目录下新建”CmpTemperature.c”，具体内容如下（其中头文件根据实际目录进行添加和修改）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/** * &lt;name&gt;CmpTemplate.c&lt;/name&gt; * &lt;description&gt; * Example for an empty runtime component frame that can be used as a starting point to develop own components. * * MANDATORY FUNCTIONS: * - ComponentEntry() * - ExportFunctions() * - ImportFunctions() * - CmpGetVersion() * - HookFunction() * &lt;/description&gt; * * &lt;copyright&gt;(c) 2003-2016 3S-Smart Software Solutions&lt;/copyright&gt; */#include "CmpStd.h"#include "CmpTemperatureDep.h"#include "../../../Application/CMP/include/mcReference.h"#include "../../../Application/CMP/Temperature/header/mcTemperatureRegulatorFB.h"USE_STMT#ifndef RTS_COMPACT_MICRO/** * &lt;description&gt;Entry function of the component. Called at startup for each component. Used to exchange function pointers with the component manager.&lt;/description&gt; * &lt;param name="pInitStruct" type="IN"&gt;Pointer to structure with: * pfExportFunctions OUT Pointer to function that exports component functions * pfImportFunctions OUT Pointer to function that imports functions from other components * pfGetVersion OUT Pointer to function to get component version * pfRegisterAPI IN Pointer to component mangager function to register a api function * pfGetAPI IN Pointer to component mangager function to get a api function * pfCallHook IN Pointer to component mangager function to call a hook function * &lt;/param&gt; * &lt;result&gt;ERR_OK if component could be initialized, else error code.&lt;/result&gt; */DLL_DECL int CDECL ComponentEntry(INIT_STRUCT *pInitStruct)&#123; pInitStruct-&gt;CmpId = COMPONENT_ID; pInitStruct-&gt;pfExportFunctions = ExportFunctions; pInitStruct-&gt;pfImportFunctions = ImportFunctions; pInitStruct-&gt;pfGetVersion = CmpGetVersion; pInitStruct-&gt;pfHookFunction = HookFunction; pInitStruct-&gt;pfCreateInstance = NULL; pInitStruct-&gt;pfDeleteInstance = NULL; s_pfCMRegisterAPI = pInitStruct-&gt;pfCMRegisterAPI; s_pfCMRegisterAPI2 = pInitStruct-&gt;pfCMRegisterAPI2; s_pfCMGetAPI = pInitStruct-&gt;pfCMGetAPI; s_pfCMGetAPI2 = pInitStruct-&gt;pfCMGetAPI2; s_pfCMCallHook = pInitStruct-&gt;pfCMCallHook; s_pfCMRegisterClass = pInitStruct-&gt;pfCMRegisterClass; s_pfCMCreateInstance = pInitStruct-&gt;pfCMCreateInstance; return ERR_OK;&#125;/** * &lt;description&gt;Publish exported functions to the component manager, to make them available for other components. * Use generated macro EXPORT_STMT.&lt;/description&gt; * &lt;result&gt;ERR_OK or error code in case of error&lt;/result&gt; */static int CDECL ExportFunctions(void)&#123; /* Macro to export functions */ EXPORT_STMT; return ERR_OK;&#125;/** * &lt;description&gt;Import function pointers from other components. Use generated macro IMPORT_STMT.&lt;/description&gt; * &lt;result&gt;ERR_OK or error code if function name could not be resolved&lt;/result&gt; */static int CDECL ImportFunctions(void)&#123; /* Macro to import functions */ IMPORT_STMT; return ERR_OK;&#125;/** * &lt;description&gt;Return the version of our component.&lt;/description&gt; * &lt;result&gt;Version as defined in dep file&lt;/result&gt; */static RTS_UI32 CDECL CmpGetVersion(void)&#123; return CMP_VERSION;&#125;#endif/** * &lt;description&gt;Hook function to get all broadcast hooks of the component manager. All init and exit stuff must be implemented here!&lt;/description&gt; * &lt;param name="ulHook" type="IN"&gt;Kind of hook. See CH_ definitions in CmpItf.h for details.&lt;/param&gt; * &lt;param name="ulParam1" type="IN"&gt;Hook specific first parameter. See definitions in CmpItf.h for details.&lt;/param&gt; * &lt;param name="ulParam2" type="IN"&gt;Hook specific second parameter. See definitions in CmpItf.h for details.&lt;/param&gt; * &lt;result&gt;Error code&lt;/result&gt; */static RTS_RESULT CDECL HookFunction(RTS_UI32 ulHook, RTS_UINTPTR ulParam1, RTS_UINTPTR ulParam2)&#123; switch (ulHook) &#123; case CH_INIT: break; case CH_INIT2: break; case CH_INIT3: break; case CH_INIT_TASKS: break; case CH_INIT_COMM: break; case CH_INIT_FINISHED: break; /* Cyclic */ case CH_COMM_CYCLE: break;#ifndef RTS_COMPACT_MICRO case CH_EXIT_COMM: break; case CH_EXIT_TASKS: break; case CH_EXIT3: break; case CH_EXIT2: break; case CH_EXIT: break;#endif default: break; &#125; return ERR_OK;&#125; 拷贝”CmpTemperatureDep.h”到”CODESYS”目录下的”CmpTemperature”文件夹中。注意修改代码中#define EXPORT_EXTREF_STMT段中，将最后一段的的反斜杠去掉。代码中的0x8A30DA7C、0x3929FC59两个数据是连接CODESYS和底层平台的接口地址，对库进行修改重新编译后这个值会对应的改变，因此在底层平台中也需要对这两个值进行修改！！！ 1234567#define EXPORT_EXTREF_STMT \ &#123; (RTS_VOID_FCTPTR)mc_temperatureregulator__main, "mc_temperatureregulator__main", 0x8A30DA7C, 0x00000000 &#125;,\ &#123; (RTS_VOID_FCTPTR)mc_temperatureregulator__fb_init, "mc_temperatureregulator__fb_init", 0x3929FC59, 0x00000000 &#125;, #else#define EXPORT_EXTREF_STMT#endif 拷贝”CmpTemperatureItf.h”到”CODESYS”目录下的”CmpTemperature”文件夹中，保留一下代码段，其余删除。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 /** * &lt;interfacename&gt;CmpTemperature&lt;/interfacename&gt; * &lt;description&gt;&lt;/description&gt; * * &lt;copyright&gt;&lt;/copyright&gt; */ #ifndef _CMPTEMPERATUREITF_H_#define _CMPTEMPERATUREITF_H_ /** EXTERN LIB SECTION BEGIN **//* Comments are ignored for m4 compiler so restructured text can be used. */#ifdef __cplusplusextern "C" &#123;#endif/** EXTERN LIB SECTION END **/typedef struct&#123; IBase_C *pBase;&#125; ICmpTemperature_C;#ifdef CPLUSPLUSclass ICmpTemperature : public IBase&#123; public:&#125;; #ifndef ITF_CmpTemperature #define ITF_CmpTemperature static ICmpTemperature *pICmpTemperature = NULL; #endif #define EXTITF_CmpTemperature#else /*CPLUSPLUS*/ typedef ICmpTemperature_C ICmpTemperature; #ifndef ITF_CmpTemperature #define ITF_CmpTemperature #endif #define EXTITF_CmpTemperature#endif#ifdef CPLUSPLUS_ONLY #undef CPLUSPLUS_ONLY#endif#endif /*_CMPTEMPERATUREITF_H_*/ 在”CMP”文件夹中新建文件夹”Temperature”，在文件夹”Temperature”下，新建文件夹”header”、”source”，在文件夹”header”下新建头文件”mcTemperatureRegulatorFB.h”，具体内容如下： 1234567891011121314151617181920212223//----------------------------------------------------------------------------//// NAME OF PROJECT: xxxxxxx Version: 1.0 (development) ////----------------------------------------------------------------------------//// NAME OF SOURCE FILE: MC_TEMPERATUREREGULATORFB.h ////----------------------------------------------------------------------------//// //// Data of creation: 2018.04.10 //// Data of last modification: 2016.04.10 //// //// DESCRIPTION: //// ////----------------------------------------------------------------------------//// NAME OF PROJECT FILE: ////----------------------------------------------------------------------------//// UTILIZING COMPILER: Texas Instrument Code Composer Studio V6 ////----------------------------------------------------------------------------//// XXX Xxx - Xxxxx ////----------------------------------------------------------------------------//#ifndef _MC_TEMPERATUREREGULATORFB_H_#define _MC_TEMPERATUREREGULATORFB_H_#endif /*_MC_TEMPERATUREREGULATORFB_H_*/ 拷贝”CmpTemperatureItf.h”头文件中字段/** EXTERN LIB SECTION BEGIN **/和/** EXTERN LIB SECTION END **/之间的内容到”mcTemperatureRegulatorFB.h”中。 在文件夹”source”下新建C文件”mcTemperatureRegulatorFB.c”，具体内容如下（其中头文件根据实际目录进行添加和修改）： 1234567891011121314151617181920212223242526272829303132333435363738//----------------------------------------------------------------------------//// NAME OF PROJECT: xxxxxx Version: 1.0 (development) ////----------------------------------------------------------------------------//// NAME OF SOURCE FILE: MC_TEMPERATUREREGULATORFB.c ////----------------------------------------------------------------------------//// //// Data of creation: 2018.04.10 //// Data of last modification: 2016.04.10 //// //// DESCRIPTION: //// ////----------------------------------------------------------------------------//// NAME OF PROJECT FILE: ////----------------------------------------------------------------------------//// UTILIZING COMPILER: Texas Instrument Code Composer Studio V6 ////----------------------------------------------------------------------------//// XXX Xxx - Xxxxx ////----------------------------------------------------------------------------//// type defines#include &lt;stdbool.h&gt;#include &lt;stdint.h&gt;// application include#include "../../../../Library/Type/LIB_Type.h"#include "../../../common/Defines.h"#include "../../../API/header/configuration.h"#include "../../../PLC/header/PLCShare.h"#include "../../../COM/header/chatUSB.h"#include "../../../../Third/CODESYS/Includes/CmpStd.h"#include "../../include/mcReference.h"#include "../header/mcTemperatureRegulatorFB.h" 拷贝”CmpTemperature.c”文件中的函数定义到”mcTemperatureRegulatorFB.c”文件中。 123456789void CDECL CDECL_EXT mc_temperatureregulator__fb_init(mc_temperatureregulator_fb_init_struct *p)&#123;&#125;void CDECL CDECL_EXT mc_temperatureregulator__main(mc_temperatureregulator_main_struct *p)&#123;&#125; 具体函数的实现功能，由用户在以上函数中进行实现，至此我们已经完成了从CODESYS建立FB到移植底层平台的所有步骤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Allegro添加Logo利器]]></title>
      <url>%2F2017%2F03%2F24%2FAllegro%E6%B7%BB%E5%8A%A0Logo%E5%88%A9%E5%99%A8%2F</url>
      <content type="text"><![CDATA[LogoMaker Skill Utility LogoMaker Skill Utility是一款不错的小插件，在Allegro中添加的PCB Logo精细度比较高，PCB实物上Logo基本没啥毛刺，边角处理的比较光滑。 插件安装步骤 Allegro下我们利用logoMaker Skill utility来实现PCB Logo的添加。 下载最新的potrace 解压potrace文件到Cadence安装目录下 添加系统环境变量例如：POTRACE_PATH=X:\Cadence\potrace 下载最新的ImageMagick 解压ImageMagick文件到Cadence安装目录下 添加系统环境变量例如：MAGICK_HOME=X:\Cadence\ImageMagick-6.5.1-3 下载il文件logoMaker_public.il 将logoMaker_public.il文件放到skill目录下，例如：X:\Cadence\SPB_16.6\share\local\pcb\skill 打开X:\Cadence\SPB_16.6\share\local\pcb\skill目录下allegro.ilinit文件(若不存在则自己创建)，添加语句load(&quot;logoMaker_public.il&quot;) 设置完成，打开Allegro在Command窗口中输入logomaker，启动Logo添加页面，Enjoy it!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[树莓派之初体验]]></title>
      <url>%2F2017%2F03%2F21%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[关于树莓派树莓派出来已经有好几年了，从1代到现在的3代，可伶我之前都没关注过有这么个好玩的东西。树莓派用的是博通的专用芯片，国内也出了类似树莓派的板子香蕉派和香橙派用的是全志的芯片，板卡价格更低至65元，无法想象功能齐全性能杠杠的“小电脑”居然可以做到如此低成本Amazing~~~。 为了体验学习下最终入了一块二手的Pi2的板子，对于上手学习来说100块买个裸板Pi2玩玩很是实惠，树莓派相对与国产的香橙派和香蕉派性能更稳定些。 系统安装树莓派的系统安装还是很简单的，选择自己要安装的操作系统从Raspberry官网下载系统镜像。我选择是Raspbian系统，鉴于我手头上只有4G的TF卡所以选择了不带桌面的Lite版，带桌面的Raspbian系统需要8G的TF卡。 系统镜像文件下载后，先通过SDFormatter软件选择逻辑开关ON格式化TF卡，再用Win32DiskImager软件加载镜像写入到格式化后的TF卡中，至此系统安装的准备工作就完成了。 系统初始化烧好镜像的TF插入树莓派板子，系统就正式启动了，查看启动输出信息有三种方式： 接HDMI显示器和键盘 通过USB转串口TTL电平连接树莓派串口 树莓派默认开启SSH，扫描树莓派IP地址后通过SSH连接 注意：最新版本系统又默认关闭了SSH，所以下载的是最新系统的话只能选择1、2方式进行初始设置，开启SSH才能通过网络连接。 树莓派默认登录用户名：pi，密码：raspberry；登录系统需要设置修改以下配置方便日后操作。 扩展TF卡全部空间（输入：sudo raspi-config，选择1 Expand Filesystem） 启动root账户（输入：sudo passwd root，再输入2次密码） 修改软件源列表（输入：sudo nano /etc/apt/sources.list，删除文件里设置的软件源替换为以下列表） 1234567891011deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ wheezy main non-free contribdeb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ wheezy main non-free contribdeb http://mirror.sysu.edu.cn/raspbian/raspbian/ wheezy main non-free contribdeb-src http://mirror.sysu.edu.cn/raspbian/raspbian/ wheezy main non-free contribdeb http://mirrors.cqu.edu.cn/Raspbian/raspbian jessie main contrib non-free rpideb-src http://mirrors.cqu.edu.cn/Raspbian/raspbian/ jessie main contrib non-free rpideb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ jessie main non-free contribdeb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ jessie main non-free contribdeb http://mirrors.zju.edu.cn/raspbian/raspbian/ jessie main contrib non-free rpideb-src http://mirrors.zju.edu.cn/raspbian/raspbian/ jessie main contrib non-free rpi 设置静态IP（输入：sdo nano /etc/dhcpcd.conf，然后在末尾添加以下设置） interface eth0static ip_address=192.168.1.110/24static routers=192.168.1.1static domain_name_servers=202.102.152.3 114.114.114.114 如果想通过SSH登录root账户 输入：sudo nano /etc/ssh/sshd_config将PermitRootLogin no改成PermitRootLogin yes 完成以上设置后就可以重启树莓派了。 桌面系统远程VNC设置最新版的Raspbian系统已经自带VNCserver只需要在设置里启用一下，然后设置就可以用啦。 输入：sudo raspi-config 选择5.Interfacing Options 找到VNC（远程桌面），选择Yes（是）enable 输入：sudo nano /etc/init.d/vncserver 然后 复制下面的内容 右键粘贴进去 12345678910111213141516171819202122232425262728293031323334353637#!/bin/sh### BEGIN INIT INFO# Provides: vncserver# Required-Start: $local_fs# Required-Stop: $local_fs# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: Start/stop vncserver### END INIT INFO # More details see:# http://www.penguintutor.com/linux/vnc ### Customize this entry# Set the USER variable to the name of the user to start vncserver underexport USER='pi'### End customization required eval cd ~$USER case "$1" in start) # 启动命令行。此处自定义分辨率、控制台号码或其它参数。 su $USER -c '/usr/bin/vncserver -depth 16 -geometry 1024x768 :1' echo "Starting VNC server for $USER " ;; stop) # 终止命令行。此处控制台号码与启动一致。 su $USER -c '/usr/bin/vncserver -kill :1' echo "vncserver stopped" ;; *) echo "Usage: /etc/init.d/vncserver &#123;start|stop&#125;" exit 1 ;;esacexit 0 然后Ctrl+O回车保存，Ctrl+X退出文本编辑器 修改权限：sudo chmod 755 /etc/init.d/vncserver 然后添加开机启动项：sudo update-rc.d vncserver defaults 最后重启树莓派:sudo reboot 如果不出意外 树莓派开机后 就可以连接VNC了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[建站小记]]></title>
      <url>%2F2017%2F03%2F12%2F%E5%BB%BA%E7%AB%99%E5%B0%8F%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[缘由最近学习相关Python相关东西，很多开源的代码都在Github上，于是乎自己也注册了Github的账户，闲逛Github时发现很多个人博客都是放在Github上，然后就搜索Github相关建站的原理资料，基本上就是GitHub+Hexo搭建免费独立个人博客。 建站目的博客已经流行N年了，以前基本都是在第三方平台上开博，博客的分隔和布局排版均受限于第三方。但是GitHub+Hexo方式建立的个人博客就开放多了，可以选各式各样的主题风格布局方式，这点是比较吸引我的地方，建立这个博客的目的最初目的也是为了学习下这个这种方式建站，于是此次博就诞生了！ 后续想法既然开了博客那也就想后续在这里记录些个人工作、学习、生活等等相关事宜，内容上就待自己慢慢完善了。]]></content>
    </entry>

    
  
  
</search>
